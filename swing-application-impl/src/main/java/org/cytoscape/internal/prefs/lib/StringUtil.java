package org.cytoscape.internal.prefs.lib;import java.awt.FontMetrics;import java.awt.Graphics;import java.awt.Graphics2D;import java.awt.Insets;import java.awt.Rectangle;import java.awt.RenderingHints;import java.awt.geom.AffineTransform;import java.awt.geom.Rectangle2D;import java.io.IOException;import java.io.StringReader;import java.io.UnsupportedEncodingException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.DecimalFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Calendar;import java.util.Collection;import java.util.Date;import java.util.List;import java.util.Locale;import java.util.StringTokenizer;//import com.treestar.lib.graphics.GeometryUtil;//import com.treestar.lib.i18n.FormatKey;public final class StringUtil{//	public static final String DEFAULT_CHARSET = "ISO-8859-1";//	public static final String STRING_ARRAY_DELIM = "^^";	public static final String SPACE = " ";////	public static  String getCurrentDate() //	{//	 String dateStr = new String();//	 SimpleDateFormat dayFormatter = new SimpleDateFormat("dd", Locale.US); // format dictated by FCS 3.0 std.//	 SimpleDateFormat monthFormatter = new SimpleDateFormat("MMM", Locale.US); // format dictated by FCS 3.0 std.//	 SimpleDateFormat yearFormatter = new SimpleDateFormat("yyyy", Locale.US); // format dictated by FCS 3.0 std.//	 Date now = new Date();//	 dateStr = dayFormatter.format(now) + "-" + monthFormatter.format(now).toUpperCase() + "-" + yearFormatter.format(now);//	 return dateStr;//	}////	public static String getDateFileName()//	{//		 SimpleDateFormat dayFormatter = new SimpleDateFormat("dd", Locale.US); // format dictated by FCS 3.0 std.//		 SimpleDateFormat monthFormatter = new SimpleDateFormat("MM", Locale.US); // format dictated by FCS 3.0 std.//		 SimpleDateFormat yearFormatter = new SimpleDateFormat("yyyy", Locale.US); // format dictated by FCS 3.0 std.//		 Date now = new Date();//		 String s = yearFormatter.format(now) + monthFormatter.format(now) + dayFormatter.format(now);//		return s;//	}//	public static String getCurrentTime() //	{//	 String timeStr = new String();//	 SimpleDateFormat timeFormatter = new SimpleDateFormat("HH:mm:ss", Locale.US);  // format dictated by FCS 3.0 std.//	 Date now = new Date();//	 timeStr = timeFormatter.format(now);//	 return timeStr;//	}//	//	public static DecimalFormat getFormatter(int numDPs)//	{//		String f = "#";//		if (numDPs > 0)		//			f += "." + "#############".substring(0,numDPs);//		return new DecimalFormat(f);//	}//	//	public static boolean isNameInList(final String inName, final String[] strList)//	{//        if (inName == null)      return false;//        if (strList == null)	 return false;//		for (String s : strList)//			if (inName.equalsIgnoreCase(s)) return true;//		return false;//	}//	public static boolean stringInArray(String s, String[] list)//	{//		for (int i=0;i<list.length; i++)//			if (list[i] != null && list[i].equals(s))//				return true;//		return false;//	}//	public static boolean stringInList(String s, List<String> list)//	{//		if (isEmpty(s)) return false;//		for (int i=0;i<list.size(); i++)//			if (s.equals(list.get(i)))//				return true;//		return false;//	}//	public static boolean stringInArray(String s, DictKey[] list)//	{//		for (int i=0;i<list.length; i++)//			if (list[i] != null && list[i].equals(s))//				return true;//		return false;//	}	public static int indexOfArray(final String f, final String[] sa)  	{		if (f == null)            return 0;		String s = f.trim().toLowerCase();		int i, z = sa.length;		for (i = 0; i < z; i++)			if (s.equals(sa[i].trim().toLowerCase()))				return i;		return -1;	}	//	public static int indexOfArray(final String f, final DictKey[] sa)  //	{//		if (f == null)            return 0;//		String s = f.trim().toLowerCase();//		int i, z = sa.length;//		for (i = 0; i < z; i++)//			if ((sa[i].match(s)))//				return i;//		return -1;//	}	public static String removeHyphenatedPortion(final String inName)	{		String shortName = inName;		final int idx = inName.lastIndexOf('-');		if (idx > 0)			shortName = inName.substring(0, idx - 1);		return shortName;	}//	public static String findKeyword(final String target, final String inKey)	{		return findKeyword(target, inKey, 0);	}//	//	public static String findKeyword(final String target, final String inKey, final int inOffset)//	{//		final byte[] str = target.getBytes();//		final int len = target.length();//		String value = "";//		int idx = target.indexOf(inKey, 0);//		if (idx > 0)//		{//			idx += inKey.length(); // advance past the keyword//			idx++; // step over the '='//			char quoter = (char) str[idx];//			for (idx++; str[idx] != quoter && (idx < len); idx++)//				value += str[idx];//		}//		return value;//	}//	//	public static boolean looksLikeXML(String inStr)//	{//		String s = inStr.trim();//		byte[] str = s.getBytes();//		int len = str.length;//		if (str[0] != '<')				return false;//		if (str[len - 1] != '>')		return false;//		return true;//	}//	//	// note-  for xml usage, use ParseUtil.escapeXmlText//	public static String cleanHTML(String inStr)//	{//		String newLine = inStr; // .replaceAll("%", "&#37;"); // must come first, or we'll replace following ones//		newLine = newLine.replaceAll("&", "&amp;");//		newLine = newLine.replaceAll(">", "&gt;");//		newLine = newLine.replaceAll("<", "&lt;");//		newLine = newLine.replaceAll( "/", "&#47;");//		return newLine;//	}//	public static String restoreHTML(String inStr)//	{//		String newLine = inStr.replaceAll("&amp", "&;");//		newLine = newLine.replaceAll( "&gt;", ">");//		newLine = newLine.replaceAll( "&lt;", "<");//		newLine = newLine.replaceAll( "&#47;", "/");//		newLine = newLine.replaceAll("&#37;", "%"); // must come last//		return newLine;//	}//	 //	public static String after(String s, String pattern)	{	return s.substring(pattern.length(), s.length()).trim(); 	}////	public static String chompSuffix(String s)	//	{	//		if (s == null) return "";//		String t = s.trim();//		int len = t.length();//		if (len < 3) return t;//		if (t.charAt(len-2) == '-')//			return t.substring(0,len-2);//		return t;//	}////	//	public static String findElement(final String target, final String elementName, final int inOffset) throws RuntimeException//	{//		if (elementName.length() == 0 || target.length() == 0)//			return "";//		byte[] str = target.getBytes();//		String pattern = "<" + elementName;//		int startIdx = target.indexOf(pattern, inOffset);//		int endIdx = -2;//		if (startIdx > 0)//		{//			int idx = startIdx + pattern.length(); // advance past the keyword//			int nextCloseBracket = target.indexOf(">", idx);//			if (nextCloseBracket < 0)//				throw new RuntimeException("malformed XML in findElement");//			if (str[nextCloseBracket - 1] == '/')//				endIdx = nextCloseBracket + 1; // include the closing bracket//			else//			{//				String closingTag = "</" + elementName + ">";//				endIdx = target.indexOf(closingTag, startIdx);//				if (endIdx < 0)//					throw new RuntimeException("malformed XML in findElement");//			}//		}//		String value = "";//		if (endIdx > startIdx)//			value = target.substring(startIdx, endIdx);//		return value;//	}//	//	public static boolean isMultiline(String s)    {     return s.indexOf('\n') >= 0;    }//	public static int lineCount(String s)    //	  {//        int ct = 1;//        for (int i = 0; i < s.length() - 1; i++)    // don't count trailing \n (last char)//             if (s.charAt(i) == '\n')    ct++;//        return ct;//    }//	public static String truncateToColons(String in)	{		return truncateToColons(in, false);	}//	//	public static String truncateToColons(String in, boolean reverse)//	{//		if (in == null) return "";			// AST always return a nonnull string//		int idx = reverse ? in.lastIndexOf("::") : in.indexOf("::"); // fix bug #1408 - changed ":" to "::"//		String result = null;//		if (idx > 0)//			result = reverse ? in.substring(idx + 2, in.length()) : in.substring(0, idx);//		else//			result = in;//		return result.trim();//	}//	//	public static String cleanOperators(String str)//	{//		if (str == null || str.length() == 0) return str;//		str = str.replace('+', '_');//		str = str.replace('-', '_');//		str = str.replace('*', '_');//		str = str.replace('/', '_');//		return str;//	}//	//	public static String cleanWhitespace(String str)//	{//		if (str == null || str.length() == 0) return str;//		str = str.replace("\r\n", "");//		str = str.replace("\n", "");//		str = str.replace("\t", "");//		return str;//	}	//	public static String urlEncode(String str) {//		try {//			return URLEncoder.encode(str, DEFAULT_CHARSET);//			//		} catch (UnsupportedEncodingException e) {		throw new RuntimeException("Encoding "+DEFAULT_CHARSET+" required");	}//	}	//	public static String urlDecode(String str) {//		try {//			return URLDecoder.decode(str, DEFAULT_CHARSET);//			//		} catch (UnsupportedEncodingException e) {		throw new RuntimeException("Encoding "+DEFAULT_CHARSET+" required");	}//	}	//	public static String encodeStringArray(String[] arr) 					{ 		return encodeStringArray( Arrays.asList(arr) );	}//	public static String encodeStringArray(String[] arr, String separator) 	{ 		return encodeStringArray( Arrays.asList(arr) , separator);	}//	public static String encodeStringArray(Collection<String> arr) 			{		return encodeStringArray(arr, STRING_ARRAY_DELIM);	}//	//	public static String encodeStringArray(Collection<String> arr, String separator) //	{//		if (arr == null)	return null;//		//		String retVal = "";//		int index = 0;////		for (String el : arr) //		{//			if (index > 0)//				retVal += separator;//			retVal += urlEncode(el);//			index += 1;//		}//		return retVal;//	}	//	public static List<String> decodeStringArray(String target) {	return decodeStringArray(target, STRING_ARRAY_DELIM);	}//	//	public static List<String> decodeStringArray(String target, String delim) //	{//		ArrayList<String> list = new ArrayList<String>();//		StringTokenizer tokenizer = new StringTokenizer(target, delim);//		while (tokenizer.hasMoreTokens())//				list.add( urlDecode(tokenizer.nextToken()));			//		return list;//	}	//	// in "str", find all occurrences of "pattern" and replace them with "replace"//	public static String replace(String str, String pattern, String replace)//	{//		int s = 0, e = 0;//		if (pattern == null || replace == null) return str;//		StringBuffer result = new StringBuffer();//		while ((e = str.indexOf(pattern, s)) >= 0)//		{//			result.append(str.substring(s, e));//			result.append(replace);//			s = e + pattern.length();//		}//		result.append(str.substring(s));//		return result.toString();//	}	//	public static String lowerCaseFirstChar(String s)//	{//		if (StringUtil.isEmpty(s)) return s;//		return s.substring(0, 1).toLowerCase() + s.substring(1);//	}////    // The incoming string starts with some nondigits, then digits, possibly with a decimal point. Trim the string to just the digits and return the corresponding double value.//     public static double skimStrToDouble(String inStr)//    {//        int end = inStr.length();//        int i;//        for (i = 0; i < inStr.length(); i++)//        {//            char c = inStr.charAt(i);//            if (c >= '0' && c <= '9')           break;//        }//        boolean seenDot = false;//        for (; i < inStr.length(); i++)//        {//            char c = inStr.charAt(i);//            if (c == '.')//            {//                if (seenDot)                    break;//                else seenDot = true;//            }//            if ((c < '0' || c > '9') && c != '.') // if not a digit or a dot//            {//                end = i;		                break;//            }//        }//        if (end > 0 && end <= inStr.length())//        {//            String sub = inStr.substring(0, end);//            return ParseUtil.getDouble(sub);//        }//        return 0.;//    }//     //	/** eg getWordCount("a;b;c", ';') returns 3. *///	public static int getWordCount(String word, char spC)	{	    return StringUtil.getWordCount(word, 0, spC);	}////	public static int getWordCount(String word, int startIndex, char spC)//	{//	    // count the commas://	    int j, i, max = 1;//	    if (word == null)        return 0;//	    for (i = startIndex; ;)//	    {//	        if ((j = word.indexOf(spC, i)) < 0)      break;//	        i = j + 1;//	        max++;//	    }//	    return max;//	}	//	/** eg chopStringIntoArray("a;b;c", ';') returns {"a","b","c"}. *///	public static String[] chopStringIntoArray(String word, char spC)//	{//	    int z = getWordCount(word, spC);//	    String sa[] = new String[z];//	    chopStringIntoArray(sa, word, 0, spC);//	    return sa;//	}//	/** Fill an existing String array sa with words chopped out of word. *///	public static int chopStringIntoArray(String sa[], String word, int startIndex, char spC)//	{//	    int j = -1, i, k;//	    String s;//	    for (k = i = startIndex; k < sa.length; i = j + 1, k++)//	    {//	        if ((j = word.indexOf(spC, i)) < 0)          break;//	        s = (i == j) ? "" : word.substring(i, j);//	        sa[k] = s;//	    }//	    if (k < sa.length)//	    {//	        if (j < 0)     j = i;//	        sa[k++] = word.substring(j);//	    }//	    if (k < sa.length)      sa[k] = null;//	    return k;//	}//	//	/** Capitalize the first letter of a String. *///	public static String capitalize(String s)	{	    return s.substring(0,1).toUpperCase() + s.substring(1);	}	   //-------------------------------------------------------------------------------------------------------------//	public static String removeShortAndCurlies(final String inPut)//    {//    	String output = inPut.trim();//        if (output.charAt(0) == '{' && output.charAt(output.length()-1) == '}')//            output = output.substring(1, output.length() - 1);			// was -2, but substring wants endIndex, not len!//        return output;//    }        public static String cDigitChars = "0123456789";    public static String cUnsignedFloatingChars = "0123456789.";    static char kPeriod = '.';//    public static int mixedStyleCompare(String str1, String str2)  {    return macStyleCompare(str1, str2, true);    }//there are unit tests for these methods in MacStyleCompareTest.java//    public static int macStyleCompare(String str1, String str2, boolean inCaseSensitive)//    {//    	try//    	{//    	return mixedAlphaDigiCompare(str1, str1.length(), str2, str2.length(), inCaseSensitive);//    	}//    	catch (Exception e)	  { 	return inCaseSensitive ? str1.compareTo(str2) : str1.compareToIgnoreCase(str2);    	}//    }// //    private static int mixedAlphaDigiCompare(String str1, int len1, String str2, int len2, boolean inCaseSensitive)//    {//    	// If either string is nil, drop out//    	if (len1 == 0)//    	{//    		return (len2 == 0) ? 0 : -1;//    	}//    	else if (len2 == 0) return 1;//    	// Determine if first component is numeric//    	String firstChar = str1.substring(0, 1);//    	boolean num1 = IsOneOf(firstChar, cUnsignedFloatingChars);	// Numeric components CAN start with decimal//    	boolean num2 = IsOneOf(str2.substring(0, 1), cUnsignedFloatingChars);//    	boolean numericComponent = num1;//    	if (num1 != num2) numericComponent = false;	// compare as strings--will exit on first compare since they are different!//    	int idx1 = 0, idx2 = 0;//    	boolean haveDecimal1 = false;//    	boolean haveDecimal2 = false;//    	double val1, val2;//    	long iVal1, iVal2;//    	while (true)//    	{//    		if (numericComponent)	// compare numeric components//    		{//    			// Accumulate all the digits of the number in both strings//    			String numComponent1 = "", numComponent2 = "";//    			while (idx1 < len1 && IsOneOf(str1.substring(idx1, idx1 + 1), haveDecimal1 ? cDigitChars : cUnsignedFloatingChars))//    			{//    				numComponent1 += str1.substring(idx1, idx1 + 1);//numComponent1 << str1.substring(idx1, idx1 + 1);//    				haveDecimal1 |= str1.charAt(idx1) == kPeriod;//    				idx1++;//    			}//    			while (idx2 < len2 && IsOneOf(str2.substring(idx2, idx2 + 1), haveDecimal2 ? cDigitChars : cUnsignedFloatingChars))//    			{//    				numComponent2 += str2.substring(idx2, idx2 + 1);//numComponent2 << str2.substring(idx2, idx2 + 1);//    				haveDecimal2 |= str2.charAt(idx2) == kPeriod;//    				idx2++;//    			}//    			// Compare the two numbers//    			if (haveDecimal1 || haveDecimal2 || numComponent1.length() > 9 || numComponent2.length() > 9)	// as floating point//    			{//    				val1 = Double.valueOf(numComponent1);//numComponent1.CopyTo(val1);//    				val2 = Double.valueOf(numComponent2);//numComponent2.CopyTo(val2);//    				if (val1 > val2) return 1;//    				else if (val1 < val2) return -1;//    			}//    			else	// compare as integer//    			{//    				iVal1 = Integer.valueOf(numComponent1);//numComponent1.CopyTo(iVal1);//    				iVal2 = Integer.valueOf(numComponent2);//numComponent2.CopyTo(iVal2);//    				if (iVal1 > iVal2) return 1;//    				else if (iVal1 < iVal2) return -1;//    			}//    			// If we hit the end of the string(s), return whichever was shorter as the lesser//    			if (idx1 == len1 && idx2 == len2) return 0;//    			else if (idx1 == len1) return -1;//    			else if (idx2 == len2) return 1;//    			// Now begin non-numeric comparison//    			numericComponent = false;//    		}//    		else	// compare non-numeric component//    		{//    			// Compare current byte//    			if (inCaseSensitive)//    			{//    				if (str1.charAt(idx1) > str2.charAt(idx2)) return 1;//    				else if (str1.charAt(idx1) < str2.charAt(idx2)) return -1;//    			}//    			else//    			{//    				char up1 = (str1.substring(idx1, idx1 + 1)).toUpperCase().charAt(0);//    				char up2 = (str2.substring(idx2, idx2 + 1)).toUpperCase().charAt(0);//    				if (up1 > up2) return 1;//    				else if (up1 < up2) return -1;//    			}//    			// Increment pointers//    			idx1++;//    			idx2++;//    			// If we hit the end of the string(s), return whichever was shorter as the lesser//    			if (idx1 == len1 && idx2 == len2) return 0;//    			else if (idx1 == len1) return -1;//    			else if (idx2 == len2) return 1;//    			// Check to see if a numeric component is starting (must start with a digit)//    			num1 = IsOneOf(str1.substring(idx1, idx1 + 1), cDigitChars);//    			num2 = IsOneOf(str2.substring(idx2, idx2 + 1), cDigitChars);//    			if (num1 || num2)//    			{//    				// If only one is numeric, then return whichever current character component was shorter as the lesser//    				if (!num1) return -1;//    				else if (!num2) return 1;//    				// Otherewise, begin numeric comparison//    				numericComponent = true;//    			}//    		}//    	}//    }//    //    private static boolean IsOneOf(String c, String string)    {    	return string.contains(c);    }//    //    public static String extractAttributeValue(String text, String attr)//    {//    	int index = text.indexOf(attr);//    	if (index > 0)//    	{//    		int index2 = text.indexOf('"', index + attr.length() + 2);//    		if (index2 > 0)//    		{//    			String id = text.substring(index + attr.length() + 2, index2);//    			return id;//    		}//    	}//    	return null;//    }//////    public static String format(FormatKey control, Object... args)    {    	return String.format(Intl.getInstance().getCurrentLocale(), control.lookup(), args);    }//    public static String truncateText(FontMetrics fm, String text, int boxWidth)//    {//    	if (text == null || text.length() < 3) return text;//    	int chars = text.length();//    	int count = 1;//    	String truncatedText = text;//    	while(fm.stringWidth(truncatedText) > boxWidth && count <= chars)//        {//        	truncatedText = text.substring(0, chars - count) + "...";//        	count++;//        }//    	return truncatedText;//    }//    public static String truncateText(String text, int lengthPlusEllipsis)//    {//    	if (text == null || text.length() <= 3) return text;//    	int chars = text.length();//    	return (chars>lengthPlusEllipsis) ? text.substring(0,lengthPlusEllipsis-3) + "..." : text;//    }////    public static String sanitizeName(String s, String replacement)//	{//       if (s == null) return "";//       StringBuffer buffer = new StringBuffer();//        char[] ch = s.toCharArray();//        for (int i = 0; i < ch.length; i++)//        {//            if (ch[i] == '-' || ch[i] == '_' || ch[i] == ' ' || Character.isLetterOrDigit(ch[i]))//                buffer.append(ch[i]);//            else//            	buffer.append(replacement);//        }//        return buffer.toString();//	}		/** AM Unlike s1.equals(s2), will not throw an NPE if s1 is null.	 * if s1 and s2 are both null, then they are considered equal as well */	public static boolean areEqual(Object s1, Object s2) {		if (s1 == null || s2 == null)			return (s1 == s2);		//both null;		return s1.equals(s2);	}		/** Considers "" and null to be equal */	public static boolean areEqual(String s1, String s2) {		if (StringUtil.isEmpty(s1))			return StringUtil.isEmpty(s2);		return s1.equals(s2);	}		public static String repeat(String s, int times) {		StringBuilder sb = new StringBuilder();		for (int i=0; i<times; i++)			sb.append(s);		return sb.toString();	}		public static boolean isWhiteSpace(String s) {		int len = s.length();		if (len == 0) return false;		for (int i=0; i<len; i++)			if (!Character.isWhitespace(s.charAt(i)))				return false;					return true;	}		public static String lpad(String s, String padStr, int length) {		if (s.length() >= length) return s;		StringBuilder sb = new StringBuilder(s);		while(sb.length() < length)			sb.insert(0, padStr);		return sb.toString();	}	static int secondsPerMin = 60, minutesPerHour = 60, hoursPerDay = 24;	static int secondsPerHour = secondsPerMin * minutesPerHour;	static int secondsPerDay = secondsPerHour * hoursPerDay;	public static String getTimeString(Date val, double min, double max)	{		SimpleDateFormat format;		double range =  max - min;		if (range >  4 * secondsPerDay)				format = new SimpleDateFormat("dd-mm-yyyy");		else 	if (range >  2 * secondsPerHour)	format = new SimpleDateFormat("hh:mm:ss");		else 	if (range >  2 * secondsPerMin)		format = new SimpleDateFormat("mm:ss");		else format = new SimpleDateFormat("ss");		return format.format( val);	}////	public static String getTimeString(Calendar val, double min, double max)//	{//		SimpleDateFormat format;//		double range =  max - min;//		if (range >  4 * secondsPerDay)				format = new SimpleDateFormat("dd-mm-yyyy");//		else 	if (range >  2 * secondsPerHour)	format = new SimpleDateFormat("hh:mm:ss");//		else 	if (range >  2 * secondsPerMin)		format = new SimpleDateFormat("mm:ss");//		else format = new SimpleDateFormat("ss");//		//		try//		{//			return format.format( val.getTime());//		}//		catch (IllegalArgumentException e)	{ return "n/a";	}//	}//	//	public static <T> String join(String separator, Collection<T> arr) {//		if (arr == null) return "";//		StringBuilder sb = new StringBuilder();//		boolean first = true;//		for (T item : arr) {//			if (first)//				first = false;//			else//				sb.append(separator);//			if (item != null)//				sb.append(item.toString());//		}//		return sb.toString();//	}//	//	public static <T> String join(String separator, T...arr) {//		if (arr == null) return "";//		return join(separator, Arrays.asList(arr));//	}	//	public static String join(String separator, int...arr) {//		if (arr == null) return "";//		return join(separator, ArrayUtil.toList(arr));//	}//		public static String ensureSeparator(String separator, String...arr) {		return ensureSeparator(separator, true, arr);	}		public static String ensureSeparator(String separator, boolean ignoreEmpty, String...arr) {		StringBuilder sb = new StringBuilder();		boolean first = true;		for (String item : arr) {			if (item == null)				continue;			if (ignoreEmpty && item.isEmpty())				continue;			if (first)				first = false;			else			{				if (!endsWith(sb, separator) && !item.startsWith(separator))						sb.append(separator);			}						sb.append(item.toString());		}		return sb.toString();	}	//	public static String[] trim(boolean removeEmpty, String...strs)//	{//		if (strs == null) return null;//		List<String> trimmed = new ArrayList<String>(strs.length);//		for (String s : strs)//		{//			s = s.trim();//			if (!removeEmpty || !s.isEmpty())//				trimmed.add(s);//		}//		return trimmed.toArray(new String[trimmed.size()]);//	}//		public static String ensurePrefix(String str, String prefix) {		return (str.startsWith(prefix)) ? str : prefix + str;	}//	//	public static String ensureSuffix(String str, String suffix) {//		return (str.endsWith(suffix)) ? str : str + suffix;//	}		public static String rtrim(String str, String totrim)	{		return rtrim(str, totrim, 0);	}	public static String rtrim(String str, String totrim, int maxCount)	{		StringBuilder sb = new StringBuilder(str);		int cnt = 0;		while(endsWith(sb, totrim))		{			if (maxCount > 0 && cnt >= maxCount) break;			sb.delete(sb.length()-totrim.length(), sb.length());			cnt++;		}		return sb.toString();	}		public static String ltrim(String str, String totrim)	{		return ltrim(str, totrim, 0);	}	public static String ltrim(String str, String totrim, int maxCount)	{		StringBuilder sb = new StringBuilder(str);		int cnt = 0;		while(startsWith(sb, totrim))		{			if (maxCount > 0 && cnt >= maxCount) break;			sb.delete(0, totrim.length());			cnt++;		}		return sb.toString();	}		public static boolean endsWith(StringBuilder sb, String str)	{		if (sb.length() < str.length())			return false;		return str.equals(sb.substring(sb.length() - str.length()));	}		public static boolean startsWith(StringBuilder sb, String str)	{		if (sb.length() < str.length())			return false;		return str.equals(sb.substring(0, str.length()));	}		public static boolean isEmpty(String s)	{		return (s == null) || s.isEmpty();	}	public static boolean hasLength(String s)	{		return !isEmpty(s);	}	public static boolean isEmptyOrWhite(String s)	{		return (s == null) || s.trim().isEmpty();	}		/** Adds space before and after pos, returning the new equivalent to pos (e.g. if space was added before) */	public static int surroundWithWhitepace(StringBuilder text, int pos)	{		int len = text.length();		if (pos < 0 || pos >= len) return pos;		if (pos > 0 && !Character.isWhitespace(text.charAt(pos - 1)))		{			text.insert(pos, SPACE);			pos++;		}				if (!Character.isWhitespace(text.charAt(pos)))			text.insert(pos, SPACE);		return pos;	}		public static String parenthesize(String s)	{		return "(" + s + ")";	}		public static String notEmpty(String...strings)	{		for (String s : strings)			if (!isEmpty(s)) return s;		return null;	}		public static <T> T notNull(T...objects)	{		for (T o : objects)			if (o != null) return o;		return null;	}		public static String notNull(String s)	{		if (s == null) return "";		return s;	}		public static void replace(StringBuilder sb, int pos, String text)	{		sb.replace(pos, pos + text.length(), text);	}		public static String[] splitLines(String str)	{		return str.split("\n");	}//	//	public static Rectangle2D calculateMultilineStringBounds(Graphics g, String text)//	{//		Rectangle2D r = null;//		FontMetrics fm = g.getFontMetrics();//		for (String line : splitLines(text))//		{//			Rectangle2D bounds = fm.getStringBounds(line, g);//			if (r == null)		r = bounds;//			else				r = r.createUnion(bounds);//		}//		if (r == null)//			return new Rectangle2D.Double();//		return r;//	}////	public static void drawRotatedString(Graphics2D g, String text, double degrees, double x, double y)//	{//        Graphics2D g2 = g;//        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);//        AffineTransform transform = g2.getTransform();//        g2.translate(x, y);//        g2.rotate(Math.toRadians(-90));//        g2.drawString(text, 0, 0);//        g2.setTransform(transform);//		//	}//	//	public static double drawMultilineString(Graphics g, String text, double x, double y)//	{//		FontMetrics fm = g.getFontMetrics();//		for (String line : splitLines(text))//		{//			float height = fm.getLineMetrics(line, g).getHeight();//			y += height;//			g.drawString(line, (int) x, (int) y);//		}//		return y;//	}//	//	public static double getScalingToFit(double width, double height, double boundingWidth, double boundingHeight)//	{//		if (width <= 0 || height <= 0 || boundingWidth <= 0 || boundingHeight <= 0) return 1;//		double scaleX = boundingWidth / width;//		double scaleY = boundingHeight / height;//		return Math.min(scaleX, scaleY);//		//	}//	public static void drawToSize(Graphics2D g, String text, double width, double height)//	{//		Rectangle2D bounds = calculateMultilineStringBounds(g, text);//		double scaling = getScalingToFit(bounds.getWidth(), bounds.getHeight(), width, height);//		AffineTransform saveTransform = g.getTransform();//		g.translate((width - bounds.getWidth() * scaling) / 2, (height - bounds.getHeight() * scaling) / 2);		// center//		g.scale(scaling, scaling);//		drawMultilineString(g, text, 0, 0);//		g.setTransform(saveTransform);//	}//	//	public static void drawInBounds(Graphics2D g, String text, Rectangle bounds, Insets insets)//	{//		int x = bounds.x + insets.left;//		int y = bounds.y + insets.top;//		double width = Math.max(1, bounds.width - insets.left - insets.right);//		double height = Math.max(1, bounds.height - insets.top - insets.bottom);//		g.translate(x, y);//		drawToSize(g, text, width, height);//		g.translate(-x, -y);//	}////	private int fDiffIndex = 0;//	public int indexOfFirstDiff(String x, String y) {//	    if (x.length() < 2) return fDiffIndex; // finish!//	    int midx = Math.round(x.length() / 2);//	    String x1 = x.substring(0, midx);//	    String y1 = y.substring(0, midx);//	    if (x1.indexOf(y1) != -1){ // first chunk is equal//	    	fDiffIndex += x1.length();//	        indexOfFirstDiff(x.substring(midx,x.length()), y.substring(midx,y.length()));//	    } else // first chunk is not equal//	        indexOfFirstDiff(x1, y1);//	    return fDiffIndex;//	}//	//	public static String replaceFancyCharacters(String s)//	{//		StringBuilder result = new StringBuilder(s);//		for (int isb = 0; isb < result.length(); isb++)  {//	         char c = result.charAt(isb);//	         switch (c) {//	         //	         case '\u2018':  result.setCharAt(isb, '\''); break;  // left single quote//	         case '\u2019':  result.setCharAt(isb, '\''); break;  // right single quote//	         case '\u201A':  result.setCharAt(isb, '\''); break;  // lower quotation mark//	         //	         case '\u201C':  result.setCharAt(isb, '"'); break;  // left double quote//	         case '\u201D':  result.setCharAt(isb, '"'); break;  // right double quote//	         case '\u201E':  result.setCharAt(isb, '"'); break;  // double low quotation mark//	         //	         case '\u2039':  result.setCharAt(isb, '\''); break;  // Single Left-Pointing Quotation Mark//	         case '\u203A':  result.setCharAt(isb, '\''); break;  // Single right-Pointing Quotation Mark//	         //	         case '\u02DC':  result.setCharAt(isb, '~'); break;  // Small Tilde//	         //	         case '\u2013':  result.setCharAt(isb, '-'); break;  // En Dash//	         case '\u2014':  result.setCharAt(isb, '-'); break;  // EM Dash////	         default: break;//	         }//	      }//		return result.toString();//	}}